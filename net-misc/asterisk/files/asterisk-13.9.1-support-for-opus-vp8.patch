diff -Nrua asterisk-13.9.1.old/codecs/codec_opus.c asterisk-13.9.1.new/codecs/codec_opus.c
--- asterisk-13.9.1.old/codecs/codec_opus.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.9.1.new/codecs/codec_opus.c	2016-06-23 13:17:30.466401987 +0200
@@ -0,0 +1,819 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Translate between signed linear and Opus (Open Codec)
+ *
+ * \author Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * \note This work was motivated by Mozilla
+ *
+ * \ingroup codecs
+ *
+ * \extref http://www.opus-codec.org/docs/html_api-1.1.0/
+ *
+ */
+
+/*** MODULEINFO
+	 <depend>opus</depend>
+	 <support_level>core</support_level>
+***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: $")
+
+#include <opus/opus.h>
+
+#include "asterisk/translate.h"
+#include "asterisk/module.h"
+#include "asterisk/cli.h"
+#include "asterisk/config.h"
+#include "asterisk/utils.h"
+#include "asterisk/linkedlists.h"
+
+#define	BUFFER_SAMPLES	5760
+#define	MAX_CHANNELS	2
+#define	OPUS_SAMPLES	960
+
+/* Sample frame data */
+#include "asterisk/slin.h"
+#include "ex_opus.h"
+
+static struct codec_usage {
+	int encoder_id;
+	int decoder_id;
+	int encoders;
+	int decoders;
+} usage;
+
+/* Private structures */
+struct opus_coder_pvt {
+	void *opus;	/* May be encoder or decoder */
+	int sampling_rate;
+	int multiplier;
+	int id;
+	int16_t buf[BUFFER_SAMPLES];
+	int framesize;
+	int inited;
+	int channels;
+	int decode_fec_incoming;
+	int previous_lost;
+};
+
+struct opus_attr {
+	unsigned int maxbitrate;
+	unsigned int maxplayrate;
+	unsigned int unused; /* was minptime */
+	unsigned int stereo;
+	unsigned int cbr;
+	unsigned int fec;
+	unsigned int dtx;
+	unsigned int spropmaxcapturerate; /* FIXME: not utilised, yet */
+	unsigned int spropstereo; /* FIXME: currently, we are just mono */
+};
+
+/* Helper methods */
+static int opus_encoder_construct(struct ast_trans_pvt *pvt, int sampling_rate)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	struct opus_attr *attr = pvt->explicit_dst ? ast_format_get_attribute_data(pvt->explicit_dst) : NULL;
+	const opus_int32 bitrate = attr ? attr->maxbitrate  : 510000;
+	const int maxplayrate    = attr ? attr->maxplayrate : 48000;
+	const int channels       = attr ? attr->stereo + 1  : 1;
+	const opus_int32 vbr     = attr ? !(attr->cbr)      : 1;
+	const opus_int32 fec     = attr ? attr->fec         : 1;
+	const opus_int32 dtx     = attr ? attr->dtx         : 0;
+	const int application    = OPUS_APPLICATION_VOIP;
+	int status = 0;
+
+	opvt->opus = opus_encoder_create(sampling_rate, channels, application, &status);
+
+	if (status != OPUS_OK) {
+		ast_log(LOG_ERROR, "Error creating the Opus encoder: %s\n", opus_strerror(status));
+		return -1;
+	}
+
+	if (sampling_rate <= 8000 || maxplayrate <= 8000) {
+		status = opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_NARROWBAND));
+	} else if (sampling_rate <= 12000 || maxplayrate <= 12000) {
+		status = opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_MEDIUMBAND));
+	} else if (sampling_rate <= 16000 || maxplayrate <= 16000) {
+		status = opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
+	} else if (sampling_rate <= 24000 || maxplayrate <= 24000) {
+		status = opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_SUPERWIDEBAND));
+	} /* else we use the default: OPUS_BANDWIDTH_FULLBAND */
+
+	if (0 < bitrate && bitrate != 510000) {
+		status = opus_encoder_ctl(opvt->opus, OPUS_SET_BITRATE(bitrate));
+	} /* else we use the default: OPUS_AUTO */
+	status = opus_encoder_ctl(opvt->opus, OPUS_SET_VBR(vbr));
+	status = opus_encoder_ctl(opvt->opus, OPUS_SET_INBAND_FEC(fec));
+	status = opus_encoder_ctl(opvt->opus, OPUS_SET_DTX(dtx));
+
+	opvt->sampling_rate = sampling_rate;
+	opvt->multiplier = 48000/sampling_rate;
+	opvt->framesize = sampling_rate/50;
+	opvt->id = ast_atomic_fetchadd_int(&usage.encoder_id, 1) + 1;
+
+	ast_atomic_fetchadd_int(&usage.encoders, +1);
+
+	ast_debug(3, "Created encoder #%d (%d -> opus)\n", opvt->id, sampling_rate);
+
+	return 0;
+}
+
+static int opus_decoder_construct(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	/* struct opus_attr *attr = ast_format_get_attribute_data(f->subclass.format); */
+	int error = 0;
+
+	opvt->sampling_rate = pvt->t->dst_codec.sample_rate;
+	opvt->multiplier = 48000/opvt->sampling_rate;
+	opvt->channels = /* attr ? attr->spropstereo + 1 :*/ 1; /* FIXME */;
+
+	opvt->opus = opus_decoder_create(opvt->sampling_rate, opvt->channels, &error);
+
+	if (error != OPUS_OK) {
+		ast_log(LOG_ERROR, "Error creating the Opus decoder: %s\n", opus_strerror(error));
+		return -1;
+	}
+
+	opvt->id = ast_atomic_fetchadd_int(&usage.decoder_id, 1) + 1;
+
+	ast_atomic_fetchadd_int(&usage.decoders, +1);
+
+	ast_debug(3, "Created decoder #%d (opus -> %d)\n", opvt->id, opvt->sampling_rate);
+
+	return 0;
+}
+
+/* Translator callbacks */
+static int lintoopus_new(struct ast_trans_pvt *pvt)
+{
+	return opus_encoder_construct(pvt, pvt->t->src_codec.sample_rate);
+}
+
+static int opustolin_new(struct ast_trans_pvt *pvt)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+
+	opvt->previous_lost = 0; /* we are new and have not lost anything */
+	opvt->inited = 0; /* we do not know the "sprop" values, yet */
+
+	return 0;
+}
+
+static int lintoopus_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+	memcpy(opvt->buf + pvt->samples, f->data.ptr, f->datalen);
+	pvt->samples += f->samples;
+
+	return 0;
+}
+
+static struct ast_frame *lintoopus_frameout(struct ast_trans_pvt *pvt)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	struct ast_frame *result = NULL;
+	struct ast_frame *last = NULL;
+	int samples = 0; /* output samples */
+
+	while (pvt->samples >= opvt->framesize) {
+		/* status is either error or output bytes */
+		const int status = opus_encode(opvt->opus,
+			opvt->buf + samples,
+			opvt->framesize,
+			pvt->outbuf.uc,
+			BUFFER_SAMPLES);
+
+		samples += opvt->framesize;
+		pvt->samples -= opvt->framesize;
+
+		if (status < 0) {
+			ast_log(LOG_ERROR, "Error encoding the Opus frame: %s\n", opus_strerror(status));
+		} else {
+			struct ast_frame *current = ast_trans_frameout(pvt,
+				status,
+				OPUS_SAMPLES);
+
+			if (!current) {
+				continue;
+			} else if (last) {
+				AST_LIST_NEXT(last, frame_list) = current;
+			} else {
+				result = current;
+			}
+			last = current;
+		}
+	}
+
+	/* Move the data at the end of the buffer to the front */
+	if (samples) {
+		memmove(opvt->buf, opvt->buf + samples, pvt->samples * 2);
+	}
+
+	return result;
+}
+
+static int opustolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	int decode_fec;
+	int frame_size;
+	opus_int16 *dst;
+	opus_int32 len;
+	unsigned char *src;
+	int status;
+
+	if (!opvt->inited && f->datalen == 0) {
+		return 0; /* we cannot start without data */
+	} else if (!opvt->inited) { /* 0 < f->datalen */
+		status = opus_decoder_construct(pvt, f);
+		opvt->inited = 1;
+		if (status) {
+			return status;
+		}
+	}
+
+	/*
+	 * When we get a frame indicator (ast_null_frame), format is NULL. Because FEC
+	 * status can change any time (SDP re-negotiation), we save again and again.
+	 */
+	if (f->subclass.format) {
+		struct opus_attr *attr = ast_format_get_attribute_data(f->subclass.format);
+
+		if (attr) {
+			opvt->decode_fec_incoming = attr->fec;
+		}
+	}
+	decode_fec = opvt->decode_fec_incoming;
+
+	/*
+	 * The Opus Codec, actually its library allows
+	 * - Forward-Error Correction (FEC), and
+	 * - native Packet-Loss Concealment (PLC).
+	 * The sender might include FEC. If there is no FEC, because it was not send
+	 * or the FEC data got lost, the API of the Opus library does PLC instead.
+	 * Therefore we have three boolean variables:
+	 * - current frame got lost: f->datalen == 0,
+	 * - previous frame got lost: opvt->previous_lost, and
+	 * - FEC negotiated on SDP layer: decode_fec.
+	 * Now, we go through all cases. Because some cases use the same source code
+	 * we have less than 8 (2^3) cases.
+	 *
+	 * Some notes on the coding style of this section:
+	 * This code section is passed for each incoming frame, normally every
+	 * 20 milliseconds. For each channel, this code is passed individually.
+	 * Therefore, this code should be as performant as possible. On the other
+	 * hand, PLC plus FEC is complicated. Therefore, code readability is one
+	 * prerequisite to understand, debug, and review this code section. Because
+	 * we do have optimising compilers, we are able to sacrify optimised code
+	 * for code readability. If you find an error or unnecessary calculation
+	 * which is not optimised = removed by your compiler, please, create an
+	 * issue on <https://github.com/seanbright/asterisk-opus/issues>. I am just
+	 * a human and human do mistakes. However, humans loves to learn.
+	 *
+	 * Source-code examples are
+	 * - <https://git.xiph.org/?p=opus.git;a=history;f=src/opus_demo.c>,
+	 * - <https://freeswitch.org/stash/projects/FS/repos/freeswitch/browse/src/mod/codecs/mod_opus/mod_opus.c>
+	 * and the official mailing list itself:
+	 * <https://www.google.de/search?q=site:lists.xiph.org+opus>.
+	 */
+
+	/* Case 1 and 2 */
+	if (f->datalen == 0 && opvt->previous_lost) {
+		/*
+		 * If this frame and the previous frame got lost, we do not have any
+		 * data for FEC. Therefore, we go for PLC on the previous frame. However,
+		 * the next frame could include FEC for the currently lost frame.
+		 * Therefore, we "wait" for the next frame to fix the current frame.
+		 */
+		decode_fec = 0; /* = do PLC */
+		opus_decoder_ctl(opvt->opus, OPUS_GET_LAST_PACKET_DURATION(&frame_size));
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels);
+		len = 0;
+		src = NULL;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		/*
+		 * Save the state of the current frame, whether it is lost = "wait".
+		 * That way, we are able to decide whether to do FEC next time.
+		 */
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+
+	/* Case 3 */
+	if (f->datalen == 0 && !decode_fec) { /* !opvt->previous_lost */
+		/*
+		 * The sender stated in SDP: "I am not going to provide FEC". Therefore,
+		 * we do not wait for the next frame and do PLC right away.
+		 */
+		decode_fec = 0;
+		opus_decoder_ctl(opvt->opus, OPUS_GET_LAST_PACKET_DURATION(&frame_size));
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels);
+		len = f->datalen;
+		src = NULL;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+
+	/* Case 4 */
+	if (f->datalen == 0) { /* decode_fec && !opvt->previous_lost */
+		/*
+		 * The previous frame was of no issue. Therefore, we do not have to
+		 * reconstruct it. We do not have any data in the current frame but the
+		 * sender might give us FEC with the next frame. We cannot do anything
+		 * but wait for the next frame. Till Asterisk 13.7, this creates the
+		 * warning "opustolin48 did not update samples 0". Please, ignore this
+		 * warning or apply the patch included in the GitHub repository.
+		 */
+		status = 0; /* no samples to add currently */
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+
+	/* Case 5 and 6 */
+	if (!opvt->previous_lost) { /* 0 < f->datalen */
+		/*
+		 * The perfect case - the previous frame was not lost and we have data
+		 * in the current frame. Therefore, neither FEC nor PLC are required.
+		 */
+		decode_fec = 0;
+		frame_size = BUFFER_SAMPLES / opvt->multiplier; /* parse everything */
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels);
+		len = f->datalen;
+		src = f->data.ptr;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+
+	/* Case 7 */
+	if (!decode_fec) { /* 0 < f->datalen && opvt->previous_lost */
+		/*
+		 * The previous frame got lost and the sender stated in SDP: "I am not
+		 * going to provide FEC". Therefore, we do PLC. Furthermore, we try to
+		 * decode the current frame because we have data. This creates jitter
+		 * because we create double the amount of frames as normal, see
+		 * <https://issues.asterisk.org/jira/browse/ASTERISK-25483>. If this is
+		 * an issue for your use-case, please, file and issue report on
+		 * <https://github.com/seanbright/asterisk-opus/issues>.
+		 */
+		decode_fec = 0;
+		opus_decoder_ctl(opvt->opus, OPUS_GET_LAST_PACKET_DURATION(&frame_size));
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels);
+		len = 0;
+		src = NULL;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		decode_fec = 0;
+		frame_size = BUFFER_SAMPLES / opvt->multiplier; /* parse everything */
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels); /* append after PLC data */
+		len = f->datalen;
+		src = f->data.ptr;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+
+	/* Case 8; Last Case */
+	{ /* 0 < f->datalen && opvt->previous_lost && decode_fec */
+		decode_fec = 1;
+		opus_decoder_ctl(opvt->opus, OPUS_GET_LAST_PACKET_DURATION(&frame_size));
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels);
+		len = f->datalen;
+		src = f->data.ptr;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		decode_fec = 0;
+		frame_size = BUFFER_SAMPLES / opvt->multiplier; /* parse everything */
+		dst = pvt->outbuf.i16 + (pvt->samples * opvt->channels); /* append after FEC data */
+		len = f->datalen;
+		src = f->data.ptr;
+		status = opus_decode(opvt->opus, src, len, dst, frame_size, decode_fec);
+		if (status < 0) {
+			ast_log(LOG_ERROR, "%s\n", opus_strerror(status));
+		} else {
+			pvt->samples += status;
+			pvt->datalen += status * opvt->channels * sizeof(int16_t);
+		}
+		opvt->previous_lost = (f->datalen == 0 || status < 0);
+		return 0;
+	}
+}
+
+static void lintoopus_destroy(struct ast_trans_pvt *arg)
+{
+	struct opus_coder_pvt *opvt = arg->pvt;
+
+	if (!opvt || !opvt->opus) {
+		return;
+	}
+
+	opus_encoder_destroy(opvt->opus);
+	opvt->opus = NULL;
+
+	ast_atomic_fetchadd_int(&usage.encoders, -1);
+
+	ast_debug(3, "Destroyed encoder #%d (%d->opus)\n", opvt->id, opvt->sampling_rate);
+}
+
+static void opustolin_destroy(struct ast_trans_pvt *arg)
+{
+	struct opus_coder_pvt *opvt = arg->pvt;
+
+	if (!opvt || !opvt->opus) {
+		return;
+	}
+
+	opus_decoder_destroy(opvt->opus);
+	opvt->opus = NULL;
+
+	ast_atomic_fetchadd_int(&usage.decoders, -1);
+
+	ast_debug(3, "Destroyed decoder #%d (opus->%d)\n", opvt->id, opvt->sampling_rate);
+}
+
+static char *handle_cli_opus_show(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct codec_usage copy;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "opus show";
+		e->usage =
+			"Usage: opus show\n"
+			"       Displays Opus encoder/decoder utilization.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 2) {
+		return CLI_SHOWUSAGE;
+	}
+
+	copy = usage;
+
+	ast_cli(a->fd, "%d/%d encoders/decoders are in use.\n", copy.encoders, copy.decoders);
+
+	return CLI_SUCCESS;
+}
+
+/* Translators */
+static struct ast_translator opustolin = {
+        .table_cost = AST_TRANS_COST_LY_LL_ORIGSAMP,
+        .name = "opustolin",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 8000,
+        },
+        .format = "slin",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = (BUFFER_SAMPLES / (48000 / 8000)) * 2, /* because of possible FEC */
+        .buf_size = (BUFFER_SAMPLES / (48000 / 8000)) * MAX_CHANNELS * sizeof(opus_int16) * 2,
+        .native_plc = 1,
+};
+
+static struct ast_translator lintoopus = {
+        .table_cost = AST_TRANS_COST_LL_LY_ORIGSAMP,
+        .name = "lintoopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 8000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .sample = slin8_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin12 = {
+        .table_cost = AST_TRANS_COST_LY_LL_ORIGSAMP - 1,
+        .name = "opustolin12",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 12000,
+        },
+        .format = "slin12",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = (BUFFER_SAMPLES / (48000 / 12000)) * 2, /* because of possible FEC */
+        .buf_size = (BUFFER_SAMPLES / (48000 / 12000)) * MAX_CHANNELS * sizeof(opus_int16) * 2,
+        .native_plc = 1,
+};
+
+static struct ast_translator lin12toopus = {
+        .table_cost = AST_TRANS_COST_LL_LY_ORIGSAMP - 1,
+        .name = "lin12toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 12000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin16 = {
+        .table_cost = AST_TRANS_COST_LY_LL_ORIGSAMP - 2,
+        .name = "opustolin16",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 16000,
+        },
+        .format = "slin16",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = (BUFFER_SAMPLES / (48000 / 16000)) * 2, /* because of possible FEC */
+        .buf_size = (BUFFER_SAMPLES / (48000 / 16000)) * MAX_CHANNELS * sizeof(opus_int16) * 2,
+        .native_plc = 1,
+};
+
+static struct ast_translator lin16toopus = {
+        .table_cost = AST_TRANS_COST_LL_LY_ORIGSAMP - 2,
+        .name = "lin16toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 16000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .sample = slin16_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin24 = {
+        .table_cost = AST_TRANS_COST_LY_LL_ORIGSAMP - 4,
+        .name = "opustolin24",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 24000,
+        },
+        .format = "slin24",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = (BUFFER_SAMPLES / (48000 / 24000)) * 2, /* because of possible FEC */
+        .buf_size = (BUFFER_SAMPLES / (48000 / 24000)) * MAX_CHANNELS * sizeof(opus_int16) * 2,
+        .native_plc = 1,
+};
+
+static struct ast_translator lin24toopus = {
+        .table_cost = AST_TRANS_COST_LL_LY_ORIGSAMP - 4,
+        .name = "lin24toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 24000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin48 = {
+        .table_cost = AST_TRANS_COST_LY_LL_ORIGSAMP - 8,
+        .name = "opustolin48",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "slin48",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES * 2, /* twice, because of possible FEC */
+        .buf_size = BUFFER_SAMPLES * MAX_CHANNELS * sizeof(opus_int16) * 2,
+        .native_plc = 1,
+};
+
+static struct ast_translator lin48toopus = {
+        .table_cost = AST_TRANS_COST_LL_LY_ORIGSAMP - 8,
+        .name = "lin48toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_cli_entry cli[] = {
+	AST_CLI_DEFINE(handle_cli_opus_show, "Display Opus codec utilization.")
+};
+
+static int reload(void)
+{
+	/* Reload does nothing */
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	int res;
+
+	res = ast_unregister_translator(&opustolin);
+	res |= ast_unregister_translator(&lintoopus);
+	res |= ast_unregister_translator(&opustolin12);
+	res |= ast_unregister_translator(&lin12toopus);
+	res |= ast_unregister_translator(&opustolin16);
+	res |= ast_unregister_translator(&lin16toopus);
+	res |= ast_unregister_translator(&opustolin24);
+	res |= ast_unregister_translator(&lin24toopus);
+	res |= ast_unregister_translator(&opustolin48);
+	res |= ast_unregister_translator(&lin48toopus);
+
+	ast_cli_unregister_multiple(cli, ARRAY_LEN(cli));
+
+	return res;
+}
+
+static int load_module(void)
+{
+	int res;
+
+	res = ast_register_translator(&opustolin);
+	res |= ast_register_translator(&lintoopus);
+	res |= ast_register_translator(&opustolin12);
+	res |= ast_register_translator(&lin12toopus);
+	res |= ast_register_translator(&opustolin16);
+	res |= ast_register_translator(&lin16toopus);
+	res |= ast_register_translator(&opustolin24);
+	res |= ast_register_translator(&lin24toopus);
+	res |= ast_register_translator(&opustolin48);
+	res |= ast_register_translator(&lin48toopus);
+
+	ast_cli_register_multiple(cli, ARRAY_LEN(cli));
+
+	return res;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Opus Coder/Decoder",
+	.load = load_module,
+	.unload = unload_module,
+	.reload = reload,
+	);
diff -Nrua asterisk-13.9.1.old/codecs/ex_opus.h asterisk-13.9.1.new/codecs/ex_opus.h
--- asterisk-13.9.1.old/codecs/ex_opus.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.9.1.new/codecs/ex_opus.h	2016-06-23 13:17:03.718403235 +0200
@@ -0,0 +1,35 @@
+/*! \file
+ * \brief 8-bit data
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Distributed under the terms of the GNU General Public License
+ *
+ */
+
+/* Opus, a 20ms sample */
+static uint8_t ex_opus[] = {
+	0x4b, 0x41, 0x25, 0x0b, 0xe4, 0x55, 0xc6, 0x74,
+	0xda, 0xbb, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static struct ast_frame *opus_sample(void)
+{
+	static struct ast_frame f = {
+		.frametype = AST_FRAME_VOICE,
+		.datalen = sizeof(ex_opus),
+		.samples = OPUS_SAMPLES,
+		.mallocd = 0,
+		.offset = 0,
+		.src = __PRETTY_FUNCTION__,
+		.data.ptr = ex_opus,
+	};
+
+	f.subclass.format = ast_format_opus;
+
+	return &f;
+}
diff -Nrua asterisk-13.9.1.old/formats/format_vp8.c asterisk-13.9.1.new/formats/format_vp8.c
--- asterisk-13.9.1.old/formats/format_vp8.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.9.1.new/formats/format_vp8.c	2016-06-23 13:16:57.714403515 +0200
@@ -0,0 +1,203 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Save to raw, headerless VP8 data.
+ *
+ * \author Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * \note Basically a "clone" of the H.264 passthrough format
+ *
+ * \arg File name extension: VP8
+ * \ingroup formats
+ * \arg See \ref AstVideo
+ */
+
+/*** MODULEINFO
+	 <support_level>core</support_level>
+***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: $")
+
+#include "asterisk/mod_format.h"
+#include "asterisk/module.h"
+#include "asterisk/endian.h"
+#include "asterisk/format_cache.h"
+
+/* VP8 passthrough */
+#define FRAME_ENDED	0x8000
+
+#define BUF_SIZE	4096
+struct vp8_desc {
+	unsigned int lastts;
+};
+
+static int vp8_open(struct ast_filestream *s)
+{
+	unsigned int ts;
+
+	if (fread(&ts, 1, sizeof(ts), s->f) < sizeof(ts)) {
+		ast_log(LOG_WARNING, "Empty file!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct ast_frame *vp8_read(struct ast_filestream *s, int *whennext)
+{
+	int res;
+	int mark = 0;
+	unsigned short len;
+	unsigned int ts;
+	struct vp8_desc *fs = (struct vp8_desc *) s->_private;
+
+	/* Send a frame from the file to the appropriate channel */
+	if ((res = fread(&len, 1, sizeof(len), s->f)) < 1) {
+		return NULL;
+	}
+
+	len = ntohs(len);
+	mark = (len & FRAME_ENDED) ? 1 : 0;
+	len &= 0x7fff;
+	if (len > BUF_SIZE) {
+		ast_log(LOG_WARNING, "Length %d is too long\n", len);
+		len = BUF_SIZE;	/* XXX truncate */
+	}
+	s->fr.mallocd = 0;
+	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, len);
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (res) {
+			ast_log(LOG_WARNING, "Short read (%d of %d) (%s)!\n", res, len, strerror(errno));
+		}
+		return NULL;
+	}
+	s->fr.samples = fs->lastts;
+	s->fr.datalen = len;
+	s->fr.subclass.frame_ending = mark;
+	s->fr.delivery.tv_sec = 0;
+	s->fr.delivery.tv_usec = 0;
+	if ((res = fread(&ts, 1, sizeof(ts), s->f)) == sizeof(ts)) {
+		fs->lastts = ntohl(ts);
+		*whennext = fs->lastts * 4/45;
+	} else {
+		*whennext = 0;
+	}
+	return &s->fr;
+}
+
+static int vp8_write(struct ast_filestream *s, struct ast_frame *f)
+{
+	int res;
+	unsigned int ts;
+	unsigned short len;
+	int mark;
+
+	if (f->frametype != AST_FRAME_VIDEO) {
+		ast_log(LOG_WARNING, "Asked to write non-video frame!\n");
+		return -1;
+	}
+
+	mark = f->subclass.frame_ending ? FRAME_ENDED : 0;
+	ts = htonl(f->samples);
+	if ((res = fwrite(&ts, 1, sizeof(ts), s->f)) != sizeof(ts)) {
+		ast_log(LOG_WARNING, "Bad write (%d/4): %s\n", res, strerror(errno));
+		return -1;
+	}
+
+	len = htons(f->datalen | mark);
+	if ((res = fwrite(&len, 1, sizeof(len), s->f)) != sizeof(len)) {
+		ast_log(LOG_WARNING, "Bad write (%d/2): %s\n", res, strerror(errno));
+		return -1;
+	}
+
+	if ((res = fwrite(f->data.ptr, 1, f->datalen, s->f)) != f->datalen) {
+		ast_log(LOG_WARNING, "Bad write (%d/%d): %s\n", res, f->datalen, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int vp8_seek(struct ast_filestream *fs, off_t sample_offset, int whence)
+{
+	/* No way Jose */
+	return -1;
+}
+
+static int vp8_trunc(struct ast_filestream *fs)
+{
+	int fd;
+	off_t cur;
+
+	if ((fd = fileno(fs->f)) < 0) {
+		ast_log(LOG_WARNING, "Unable to determine file descriptor for VP8 filestream %p: %s\n", fs, strerror(errno));
+		return -1;
+	}
+
+	if ((cur = ftello(fs->f)) < 0) {
+		ast_log(LOG_WARNING, "Unable to determine current position in VP8 filestream %p: %s\n", fs, strerror(errno));
+		return -1;
+	}
+
+	/* Truncate file to current length */
+	return ftruncate(fd, cur);
+}
+
+static off_t vp8_tell(struct ast_filestream *fs)
+{
+	off_t offset = ftell(fs->f);
+	return offset; /* XXX totally bogus, needs fixing */
+}
+
+static struct ast_format_def vp8_f = {
+	.name = "VP8",
+	.exts = "vp8",
+	.open = vp8_open,
+	.write = vp8_write,
+	.seek = vp8_seek,
+	.trunc = vp8_trunc,
+	.tell = vp8_tell,
+	.read = vp8_read,
+	.buf_size = BUF_SIZE + AST_FRIENDLY_OFFSET,
+	.desc_size = sizeof(struct vp8_desc),
+};
+
+static int load_module(void)
+{
+	vp8_f.format = ast_format_vp8;
+	if (ast_format_def_register(&vp8_f)) {
+		return AST_MODULE_LOAD_FAILURE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	return ast_format_def_unregister(vp8_f.name);
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Raw VP8 data",
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_APP_DEPEND
+	);
diff -Nrua asterisk-13.9.1.old/main/codec_builtin.c asterisk-13.9.1.new/main/codec_builtin.c
--- asterisk-13.9.1.old/main/codec_builtin.c	2016-06-23 13:16:16.863405421 +0200
+++ asterisk-13.9.1.new/main/codec_builtin.c	2016-06-23 13:16:27.051404946 +0200
@@ -38,6 +38,8 @@
 #include "asterisk/format_cache.h"
 #include "asterisk/frame.h"
 
+#include <opus/opus.h>
+
 enum frame_type {
 	TYPE_HIGH,     /* 0x0 */
 	TYPE_LOW,      /* 0x1 */
@@ -698,6 +700,11 @@
 	.get_length = g719_length,
 };
 
+static int opus_samples(struct ast_frame *frame)
+{
+	return opus_packet_get_nb_samples(frame->data.ptr, frame->datalen, 48000);
+}
+
 static struct ast_codec opus = {
 	.name = "opus",
 	.description = "Opus Codec",
@@ -707,6 +714,7 @@
 	.maximum_ms = 60,
 	.default_ms = 20,
 	.minimum_bytes = 10,
+	.samples_count = opus_samples,
 };
 
 static struct ast_codec jpeg = {
diff -Nrua asterisk-13.9.1.old/main/Makefile asterisk-13.9.1.new/main/Makefile
--- asterisk-13.9.1.old/main/Makefile	2016-06-23 13:16:16.861405421 +0200
+++ asterisk-13.9.1.new/main/Makefile	2016-06-23 13:16:27.050404946 +0200
@@ -43,6 +43,7 @@
 AST_LIBS+=$(URIPARSER_LIB)
 AST_LIBS+=$(UUID_LIB)
 AST_LIBS+=$(CRYPT_LIB)
+AST_LIBS+=$(OPUS_LIB)
 AST_LIBS+=$(AST_CLANG_BLOCKS_LIBS)
 
 ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc kfreebsd-gnu),)
@@ -163,6 +164,7 @@
 bucket.o: _ASTCFLAGS+=$(URIPARSER_INCLUDE)
 crypt.o: _ASTCFLAGS+=$(CRYPT_INCLUDE)
 uuid.o: _ASTCFLAGS+=$(UUID_INCLUDE)
+codec_builtin.o: _ASTCFLAGS+=$(OPUS_INCLUDE)
 
 ifneq ($(findstring ENABLE_UPLOADS,$(MENUSELECT_CFLAGS)),)
 http.o: _ASTCFLAGS+=$(GMIME_INCLUDE)
diff -Nrua asterisk-13.9.1.old/main/Makefile.orig asterisk-13.9.1.new/main/Makefile.orig
--- asterisk-13.9.1.old/main/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.9.1.new/main/Makefile.orig	2016-06-23 13:16:18.277405355 +0200
@@ -0,0 +1,393 @@
+#
+# Asterisk -- An open source telephony toolkit.
+#
+# Makefile to build main Asterisk binary
+#
+# Copyright (C) 1999-2006, Digium, Inc.
+#
+# Mark Spencer <markster@digium.com>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+-include $(ASTTOPDIR)/menuselect.makeopts $(ASTTOPDIR)/menuselect.makedeps $(ASTTOPDIR)/makeopts.embed_rules $(ASTTOPDIR)/makeopts
+
+all: asterisk
+
+include $(ASTTOPDIR)/Makefile.moddir_rules
+
+# Must include the extra ast_expr2.c, ast_expr2f.c, in case they need to be regenerated (because to force regeneration, we delete them)
+SRC:=$(wildcard *.c) ast_expr2.c ast_expr2f.c
+ifeq ($(AST_ASTERISKSSL),yes)
+SRC:=$(filter-out libasteriskssl.c,$(SRC))
+endif
+ifeq ($(PJPROJECT_BUNDLED),yes)
+SRC:=$(filter-out libasteriskpj.c,$(SRC))
+endif
+OBJSFILTER=fskmodem_int.o fskmodem_float.o cygload.o buildinfo.o
+OBJS=$(filter-out $(OBJSFILTER),$(SRC:.c=.o))
+
+# we need to link in the objects statically, not as a library, because
+# otherwise modules will not have them available if none of the static
+# objects use it.
+OBJS+=stdtime/localtime.o
+
+ASTSSL_LIBS:=$(OPENSSL_LIB)
+AST_LIBS+=$(BKTR_LIB)
+AST_LIBS+=$(LIBXML2_LIB)
+AST_LIBS+=$(LIBXSLT_LIB)
+AST_LIBS+=$(SQLITE3_LIB)
+AST_LIBS+=$(ASTSSL_LIBS)
+AST_LIBS+=$(JANSSON_LIB)
+AST_LIBS+=$(URIPARSER_LIB)
+AST_LIBS+=$(UUID_LIB)
+AST_LIBS+=$(CRYPT_LIB)
+AST_LIBS+=$(AST_CLANG_BLOCKS_LIBS)
+
+ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc kfreebsd-gnu),)
+  ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
+  AST_LIBS+=-ldl
+  endif
+  ifneq (x$(CAP_LIB),x)
+    AST_LIBS+=$(CAP_LIB)
+  endif
+  AST_LIBS+=-lpthread $(EDITLINE_LIB) -lm -lresolv
+else
+  AST_LIBS+=$(EDITLINE_LIB) -lm
+endif
+
+ifneq ($(findstring BETTER_BACKTRACES,$(MENUSELECT_CFLAGS)),)
+  AST_LIBS+=$(BFD_LIB)
+endif
+
+ifneq ($(findstring darwin,$(OSARCH)),)
+  AST_LIBS+=-lresolv
+  ASTLINK=-mmacosx-version-min=10.6 -Wl,-undefined,dynamic_lookup -force_flat_namespace
+  ASTLINK+=/usr/lib/bundle1.o
+else
+# These are used for all but Darwin
+  ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
+    ASTLINK+=-Wl,--export-dynamic
+  else
+    ASTLINK+=${GC_LDFLAGS}
+  endif
+  ifneq ($(findstring BSD,$(OSARCH)),)
+    LDFLAGS+=-L/usr/local/lib
+  endif
+endif
+
+ifeq ($(OSARCH),FreeBSD)
+  # -V is understood by BSD Make, not by GNU make.
+  BSDVERSION=$(shell make -V OSVERSION -f /usr/share/mk/bsd.port.subdir.mk)
+  AST_LIBS+=$(shell if test $(BSDVERSION) -lt 502102 ; then echo "-lc_r"; else echo "-pthread"; fi)
+  AST_LIBS+=-lcrypto
+endif
+
+ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
+  AST_LIBS+=-lminires -ldl
+  ASTLINK+=-shared -Wl,--out-implib,libasterisk.a
+endif
+ifeq ($(OSARCH),NetBSD)
+  AST_LIBS+=-lpthread -lcrypto -lm -L/usr/pkg/lib $(EDITLINE_LIB)
+endif
+
+ifeq ($(OSARCH),OpenBSD)
+  AST_LIBS+=-lcrypto -lpthread -lm $(EDITLINE_LIB)
+endif
+
+ifeq ($(OSARCH),SunOS)
+  AST_LIBS+=-lpthread -ldl -lrt -lnsl -lsocket -lresolv
+  ASTSSL_LIBS+=-L/opt/ssl/lib -L/usr/local/ssl/lib
+  ASTLINK=
+endif
+
+ifneq ($(findstring USE_HOARD_ALLOCATOR,$(MENUSELECT_CFLAGS)),)
+  ifneq ($(HOARD_LIB),)
+    AST_LIBS+=$(HOARD_LIB)
+  endif
+endif
+
+ifeq ($(GNU_LD),1)
+ASTLINK+=-Wl,--version-script,asterisk.exports
+  ifeq ($(HAVE_DYNAMIC_LIST),1)
+  ASTLINK+=-Wl,--dynamic-list,asterisk.dynamics
+  endif
+endif
+
+.PHONY: CHECK_SUBDIR
+CHECK_SUBDIR:	# do nothing, just make sure that we recurse in the subdir/
+
+editline/libedit.a: CHECK_SUBDIR
+	cd editline && test -f config.h || CFLAGS="$(PTHREAD_CFLAGS) $(subst $(ASTTOPDIR),../../,$(_ASTCFLAGS:-Werror=) $(ASTCFLAGS))" LDFLAGS="$(_ASTLDFLAGS) $(ASTLDFLAGS)" ./configure --build=$(BUILD_PLATFORM) --host=$(HOST_PLATFORM) --with-ncurses=$(NCURSES_DIR) --with-curses=$(CURSES_DIR) --with-termcap=$(TERMCAP_DIR) --with-tinfo=$(TINFO_DIR)
+	$(MAKE) -C editline libedit.a
+
+ifneq ($(findstring REBUILD_PARSERS,$(MENUSELECT_CFLAGS)),)
+ast_expr2.c ast_expr2.h: ast_expr2.y
+else
+ast_expr2.c ast_expr2.h:
+endif
+	$(ECHO_PREFIX) echo "   [BISON] $< -> $@"
+	$(CMD_PREFIX) $(BISON) -o $@ -d --name-prefix=ast_yy ast_expr2.y
+
+ifneq ($(findstring REBUILD_PARSERS,$(MENUSELECT_CFLAGS)),)
+ast_expr2f.c: ast_expr2.fl
+else
+ast_expr2f.c:
+endif
+	$(ECHO_PREFIX) echo "   [FLEX] $< -> $@"
+	$(CMD_PREFIX) $(FLEX) -o $@ ast_expr2.fl
+	$(CMD_PREFIX) sed 's@#if __STDC_VERSION__ >= 199901L@#if !defined __STDC_VERSION__ || __STDC_VERSION__ >= 199901L@' $@ > $@.fix
+	$(CMD_PREFIX) echo "#include \"asterisk.h\"" > $@
+	$(CMD_PREFIX) echo >> $@
+	$(CMD_PREFIX) cat $@.fix >> $@
+	$(CMD_PREFIX) rm $@.fix
+
+ast_expr2f.o: _ASTCFLAGS+=-Wno-unused
+
+testexpr2: ast_expr2f.c ast_expr2.c ast_expr2.h
+	$(CC) -g -c -Iinclude -DSTANDALONE ast_expr2f.c
+	$(CC) -g -c -Iinclude -DSTANDALONE ast_expr2.c
+	$(CC) -g -o testexpr2 ast_expr2f.o ast_expr2.o -lm
+	rm ast_expr2.o ast_expr2f.o
+
+ifneq ($(LIBEDIT_INTERNAL),no)
+LIBEDIT_OBJ=editline/libedit.a
+LIBEDIT_INCLUDE=-I. -Ieditline
+endif
+
+db.o: _ASTCFLAGS+=$(SQLITE3_INCLUDE)
+asterisk.o: _ASTCFLAGS+=$(LIBEDIT_INCLUDE)
+cli.o: _ASTCFLAGS+=$(LIBEDIT_INCLUDE)
+json.o: _ASTCFLAGS+=$(JANSSON_INCLUDE)
+bucket.o: _ASTCFLAGS+=$(URIPARSER_INCLUDE)
+crypt.o: _ASTCFLAGS+=$(CRYPT_INCLUDE)
+uuid.o: _ASTCFLAGS+=$(UUID_INCLUDE)
+
+ifneq ($(findstring ENABLE_UPLOADS,$(MENUSELECT_CFLAGS)),)
+http.o: _ASTCFLAGS+=$(GMIME_INCLUDE)
+endif
+
+stdtime/localtime.o: _ASTCFLAGS+=$(AST_NO_STRICT_OVERFLOW) -Wno-format-nonliteral
+
+AST_EMBED_LDSCRIPTS:=$(sort $(EMBED_LDSCRIPTS))
+AST_EMBED_LDFLAGS:=$(foreach dep,$(EMBED_LDFLAGS),$(value $(dep)))
+AST_EMBED_LIBS:=$(foreach dep,$(EMBED_LIBS),$(value $(dep)))
+OBJS:=$(sort $(OBJS))
+
+ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
+MAIN_TGT:=asterisk.dll
+asterisk: cygload
+	mv cygload.exe asterisk.exe
+
+cygload: asterisk.dll
+else
+MAIN_TGT:=asterisk
+endif
+
+ifneq ($(findstring ENABLE_UPLOADS,$(MENUSELECT_CFLAGS)),)
+GMIMELDFLAGS+=$(GMIME_LIB)
+endif
+
+$(OBJS): _ASTCFLAGS+=-DAST_MODULE=\"core\" -DAST_IN_CORE
+
+libasteriskssl.o: _ASTCFLAGS+=$(OPENSSL_INCLUDE)
+
+ifeq ($(AST_ASTERISKSSL),yes)
+# The ABI *version* of the asteriskssl library; don't change this unless there truly is a
+# non-backwards-compatible ABI change in the library
+ASTSSL_SO_VERSION=1
+
+ASTSSL_LDLIBS=-L. -lasteriskssl
+
+ifeq ($(findstring darwin,$(OSARCH)),) # not Darwin
+ASTSSL_LIB:=libasteriskssl.so
+
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTSSL_LIB)
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskssl\"
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): LIBS+=$(ASTSSL_LIBS)
+ifeq ($(GNU_LD),1)
+    $(ASTSSL_LIB).$(ASTSSL_SO_VERSION): SO_SUPPRESS_SYMBOLS=-Wl,--version-script,libasteriskssl.exports,--warn-common
+endif
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): SOLINK=$(DYLINK)
+
+# These rules are duplicated from $(ASTTOPDIR)/Makefile.rules because the library name
+# being built does not match the "%.so" pattern; there are also additional steps
+# required to build a proper shared library (as opposed to the 'loadable module'
+# type that are built by the standard rules)
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): libasteriskssl.o
+ifeq ($(GNU_LD),1)
+	$(CMD_PREFIX) $(ASTTOPDIR)/build_tools/make_linker_version_script libasteriskssl "$(LINKER_SYMBOL_PREFIX)" "$(ASTTOPDIR)"
+endif
+	$(ECHO_PREFIX) echo "   [LD] $^ -> $@"
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(CC_LDFLAGS_SO) $^ $(CC_LIBS)
+
+$(ASTSSL_LIB): $(ASTSSL_LIB).$(ASTSSL_SO_VERSION)
+	$(ECHO_PREFIX) echo "   [LN] $< -> $@"
+	$(CMD_PREFIX) if [ -x "$(LDCONFIG)" ] ; then \
+		$(LDCONFIG) $(LDCONFIG_FLAGS) . 2>/dev/null ;\
+	else \
+		$(LN) -sf $< $@ ;\
+	fi
+
+else # Darwin
+ASTSSL_LIB:=libasteriskssl.dylib
+
+# -install_name allows library to be found if installed somewhere other than
+# /lib or /usr/lib
+$(ASTSSL_LIB): _ASTLDFLAGS+=-dynamiclib -install_name $(ASTLIBDIR)/$(ASTSSL_LIB)
+$(ASTSSL_LIB): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskssl\"
+$(ASTSSL_LIB): LIBS+=$(ASTSSL_LIBS)
+$(ASTSSL_LIB): SOLINK=$(DYLINK)
+
+# Special rules for building a shared library (not a dynamically loadable module)
+$(ASTSSL_LIB): libasteriskssl.o
+	$(ECHO_PREFIX) echo "   [LD] $^ -> $@"
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(CC_LDFLAGS_SO) $^ $(CC_LIBS)
+endif
+
+endif
+
+libasteriskpj.o: _ASTCFLAGS+=$(PJPROJECT_INCLUDE)
+
+ifeq ($(PJPROJECT_BUNDLED),yes)
+
+ASTPJ_SO_VERSION=2
+ASTPJ_LDLIBS=-L. -lasteriskpj
+
+-include $(ASTTOPDIR)/$(PJPROJECT_DIR)/build.mak
+
+PJPROJECT_LDLIBS := \
+-Wl,--whole-archive \
+$(PJSUA_LIB_LDLIB) \
+$(PJSIP_UA_LDLIB) \
+$(PJSIP_SIMPLE_LDLIB) \
+$(PJSIP_LDLIB) \
+$(PJNATH_LDLIB) \
+$(PJMEDIA_CODEC_LDLIB) \
+$(PJMEDIA_VIDEODEV_LDLIB) \
+$(PJMEDIA_AUDIODEV_LDLIB) \
+$(PJMEDIA_LDLIB) \
+$(PJLIB_UTIL_LDLIB) \
+$(PJLIB_LDLIB) \
+-Wl,--no-whole-archive \
+$(APP_THIRD_PARTY_LIBS) \
+$(APP_THIRD_PARTY_EXT)
+
+ifeq ($(findstring darwin,$(OSARCH)),) # not Darwin
+ASTPJ_LIB:=libasteriskpj.so
+
+libasteriskpj.exports: $(ASTTOPDIR)/$(PJPROJECT_DIR)/pjproject.symbols
+	$(ECHO_PREFIX) echo "   [GENERATE] libasteriskpj.exports"
+ifeq ($(GNU_LD),1)
+	$(CMD_PREFIX) echo -e "{\n\tglobal:" > libasteriskpj.exports
+	$(CMD_PREFIX) sed -r -e "s/.*/\t\t$(LINKER_SYMBOL_PREFIX)&;/" $(ASTTOPDIR)/$(PJPROJECT_DIR)/pjproject.symbols >> libasteriskpj.exports
+	$(CMD_PREFIX) echo -e "\t\t$(LINKER_SYMBOL_PREFIX)ast_pj_init;\n" >> libasteriskpj.exports
+	$(CMD_PREFIX) echo -e "\tlocal:\n\t\t*;\n};" >> libasteriskpj.exports
+endif
+
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTPJ_LIB) $(PJ_LDFLAGS)
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" $(PJ_CFLAGS)
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): LIBS+=$(PJPROJECT_LDLIBS) -lssl -lcrypto -luuid -lm -lrt -lpthread
+ifeq ($(GNU_LD),1)
+    $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): SO_SUPPRESS_SYMBOLS=-Wl,--version-script,libasteriskpj.exports,--warn-common
+endif
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): SOLINK=$(DYLINK)
+
+# These rules are duplicated from $(ASTTOPDIR)/Makefile.rules because the library name
+# being built does not match the "%.so" pattern; there are also additional steps
+# required to build a proper shared library (as opposed to the 'loadable module'
+# type that are built by the standard rules)
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): libasteriskpj.o libasteriskpj.exports
+	$(ECHO_PREFIX) echo "   [LD] $< -> $@"
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(CC_LDFLAGS_SO) $< $(CC_LIBS)
+
+$(ASTPJ_LIB): $(ASTPJ_LIB).$(ASTPJ_SO_VERSION)
+	$(ECHO_PREFIX) echo "   [LN] $< -> $@"
+	$(CMD_PREFIX) if [ -x "$(LDCONFIG)" ] ; then \
+		$(LDCONFIG) $(LDCONFIG_FLAGS) . 2>/dev/null ;\
+	else \
+		$(LN) -sf $< $@ ;\
+	fi
+
+else # Darwin
+ASTPJ_LIB:=libasteriskpj.dylib
+
+# -install_name allows library to be found if installed somewhere other than
+# /lib or /usr/lib
+$(ASTPJ_LIB): _ASTLDFLAGS+=-dynamiclib -install_name $(ASTLIBDIR)/$(ASTPJ_LIB) $(PJ_LDFLAGS)
+$(ASTPJ_LIB): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" $(PJ_CFLAGS)
+$(ASTPJ_LIB): LIBS+=$(PJPROJECT_LIBS)  -lssl -lcrypto -luuid -lm -lrt -lpthread
+$(ASTPJ_LIB): SOLINK=$(DYLINK)
+
+# Special rules for building a shared library (not a dynamically loadable module)
+$(ASTPJ_LIB): libasteriskpj.o
+	$(ECHO_PREFIX) echo "   [LD] $^ -> $@"
+	$(CMD_PREFIX) $(CC) $(STATIC_BUILD) -o $@ $(CC_LDFLAGS_SO) $^ $(CC_LIBS)
+endif
+
+endif
+
+tcptls.o: _ASTCFLAGS+=$(OPENSSL_INCLUDE)
+
+$(MAIN_TGT): $(OBJS) $(ASTSSL_LIB) $(ASTPJ_LIB) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS)
+	@$(CC) -c -o buildinfo.o $(_ASTCFLAGS) buildinfo.c $(ASTCFLAGS)
+	$(ECHO_PREFIX) echo "   [LD] $(OBJS) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS) -> $@"
+	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) $(ASTSSL_LDLIBS) $(ASTPJ_LDLIBS) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS) $(LIBEDIT_LIB)
+
+ifeq ($(GNU_LD),1)
+$(MAIN_TGT): asterisk.exports
+asterisk.exports: asterisk.exports.in
+	$(CMD_PREFIX) $(ASTTOPDIR)/build_tools/make_linker_version_script asterisk $(LINKER_SYMBOL_PREFIX)
+endif
+
+bininstall:
+	$(INSTALL) -m 755 $(MAIN_TGT) "$(DESTDIR)$(ASTSBINDIR)/"
+ifeq ($(AST_ASTERISKSSL),yes)
+ifeq ($(findstring darwin,$(OSARCH)),) # not Darwin
+	$(INSTALL) -m 755 $(ASTSSL_LIB).$(ASTSSL_SO_VERSION) "$(DESTDIR)$(ASTLIBDIR)/"
+	$(LN) -sf $(ASTSSL_LIB).$(ASTSSL_SO_VERSION) "$(DESTDIR)$(ASTLIBDIR)/$(ASTSSL_LIB)"
+else # Darwin
+	$(INSTALL) -m 755 $(ASTSSL_LIB) "$(DESTDIR)$(ASTLIBDIR)/"
+endif
+endif
+ifeq ($(PJPROJECT_BUNDLED),yes)
+ifeq ($(findstring darwin,$(OSARCH)),) # not Darwin
+	$(INSTALL) -m 755 $(ASTPJ_LIB).$(ASTPJ_SO_VERSION) "$(DESTDIR)$(ASTLIBDIR)/"
+	$(LN) -sf $(ASTPJ_LIB).$(ASTPJ_SO_VERSION) "$(DESTDIR)$(ASTLIBDIR)/$(ASTPJ_LIB)"
+else # Darwin
+	$(INSTALL) -m 755 $(ASTPJ_LIB) "$(DESTDIR)$(ASTLIBDIR)/"
+endif
+endif
+ifneq ($(LDCONFIG),)
+	$(LDCONFIG) $(LDCONFIG_FLAGS) "$(DESTDIR)$(ASTLIBDIR)/"
+endif
+	$(LN) -sf asterisk "$(DESTDIR)$(ASTSBINDIR)/rasterisk"
+
+binuninstall:
+	rm -f "$(DESTDIR)$(ASTSBINDIR)/$(MAIN_TGT)"
+	rm -f "$(DESTDIR)$(ASTSBINDIR)/rasterisk"
+ifneq ($(ASTSSL_LIB).$(ASTSSL_SO_VERSION),.)
+	rm -f "$(DESTDIR)$(ASTLIBDIR)/$(ASTSSL_LIB).$(ASTSSL_SO_VERSION)"
+endif
+ifneq ($(ASTPJ_LIB).$(ASTPJ_SO_VERSION),.)
+	rm -f "$(DESTDIR)$(ASTLIBDIR)/$(ASTPJ_LIB).$(ASTPJ_SO_VERSION)"
+endif
+ifneq ($(LDCONFIG),)
+	$(LDCONFIG) $(LDCONFIG_FLAGS) "$(DESTDIR)$(ASTLIBDIR)/"
+endif
+
+clean::
+	rm -f asterisk libasteriskssl.o
+ifeq ($(AST_ASTERISKSSL),yes)
+	rm -f $(ASTSSL_LIB) $(ASTSSL_LIB).*
+endif
+	rm -f libasteriskpj.o
+	rm -f libasteriskpj.so* libasteriskpj.dynlib
+	rm -f .libasteriskpj*
+
+	rm -f asterisk.exports libasteriskssl.exports libasteriskpj.exports
+	@if [ -f editline/Makefile ]; then $(MAKE) -C editline distclean ; fi
+	@$(MAKE) -C stdtime clean
+	rm -f libresample/src/*.o
+	rm -f *.tmp
diff -Nrua asterisk-13.9.1.old/main/translate.c asterisk-13.9.1.new/main/translate.c
--- asterisk-13.9.1.old/main/translate.c	2016-06-23 13:16:16.856405422 +0200
+++ asterisk-13.9.1.new/main/translate.c	2016-06-23 13:16:37.930404438 +0200
@@ -358,6 +358,7 @@
 	pvt->f.offset = AST_FRIENDLY_OFFSET;
 	pvt->f.src = pvt->t->name;
 	pvt->f.data.ptr = pvt->outbuf.c;
+	pvt->f.seqno = 0x10000;
 
 	/*
 	 * If the translator has not provided a format
@@ -524,13 +525,46 @@
 /*! \brief do the actual translation */
 struct ast_frame *ast_translate(struct ast_trans_pvt *path, struct ast_frame *f, int consume)
 {
-	struct ast_trans_pvt *p = path;
-	struct ast_frame *out;
+	const unsigned int rtp_seqno_max_value = 0xffff;
+	struct ast_frame *out_last, *out = NULL;
+	struct ast_trans_pvt *step;
 	struct timeval delivery;
 	int has_timing_info;
 	long ts;
 	long len;
-	int seqno;
+	int seqno, frames_missing;
+
+	/* Determine the amount of lost packets for PLC */
+	/* But not at start with first frame = path->f.seqno is still 0x10000 */
+	/* But not when there is no sequence number = frame created internally */
+	if ((path->f.seqno <= rtp_seqno_max_value) && (path->f.seqno != f->seqno)) {
+		if (f->seqno < path->f.seqno) { /* seqno overrun situation */
+			frames_missing = rtp_seqno_max_value + f->seqno - path->f.seqno - 1;
+		} else {
+			frames_missing = f->seqno - path->f.seqno - 1;
+		}
+		/* Out-of-order packet - more precise: late packet */
+		if ((rtp_seqno_max_value + 1) / 2 < frames_missing) {
+			if (consume) {
+				ast_frfree(f);
+			}
+			/*
+			 * Do not pass late packets to any transcoding module, because that
+			 * confuses the state of any library (packets inter-depend). With
+			 * the next packet, this one is going to be treated as lost packet.
+			 */
+			return NULL;
+		}
+
+		if (frames_missing > 96) {
+			struct ast_str *str = ast_str_alloca(256);
+
+			/* not DEBUG but NOTICE because of WARNING in main/cannel.c:__ast_queue_frame */
+			ast_log(LOG_NOTICE, "%d lost frame(s) %d/%d %s\n", frames_missing, f->seqno, path->f.seqno, ast_translate_path_to_str(path, &str));
+		}
+	} else {
+		frames_missing = 0;
+	}
 
 	has_timing_info = ast_test_flag(f, AST_FRFLAG_HAS_TIMING_INFO);
 	ts = f->ts;
@@ -560,18 +594,93 @@
 			 f->samples, ast_format_get_sample_rate(f->subclass.format)));
 	}
 	delivery = f->delivery;
-	for (out = f; out && p ; p = p->next) {
-		struct ast_frame *current = out;
 
-		do {
-			framein(p, current);
-			current = AST_LIST_NEXT(current, frame_list);
-		} while (current);
-		if (out != f) {
-			ast_frfree(out);
+	for (out_last = NULL; frames_missing + 1; frames_missing--) {
+		struct ast_frame *frame_to_translate, *inner_head;
+		struct ast_frame missed = {
+			.frametype = AST_FRAME_VOICE,
+			.subclass.format = f->subclass.format,
+			.datalen = 0,
+			/* In RTP, the amount of samples might change anytime  */
+			/* If that happened while frames got lost, what to do? */
+			.samples = f->samples, /* FIXME */
+			.src = __FUNCTION__,
+			.data.uint32 = 0,
+			.delivery.tv_sec = 0,
+			.delivery.tv_usec = 0,
+			.flags = 0,
+			/* RTP sequence number is between 0x0001 and 0xffff */
+			.seqno = (rtp_seqno_max_value + 1 + f->seqno - frames_missing) & rtp_seqno_max_value,
+		};
+
+		if (frames_missing) {
+			frame_to_translate = &missed;
+		} else {
+			frame_to_translate = f;
+		}
+
+		/* The translation path from one format to another might contain several steps */
+		/* out* collects the result for missed frame(s) and input frame(s) */
+		/* out is the result of the conversion of all frames, translated into the destination format */
+		/* out_last is the last frame in that list, to add frames faster */
+		for (step = path, inner_head = frame_to_translate; inner_head && step; step = step->next) {
+			struct ast_frame *current, *inner_last, *inner_prev = frame_to_translate;
+
+			/* inner* collects the result of each conversion step, the input for the next step */
+			/* inner_head is a list of frames created by each conversion step */
+			/* inner_last is the last frame in that list, to add frames faster */
+			for (inner_last = NULL, current = inner_head; current; current = AST_LIST_NEXT(current, frame_list)) {
+				struct ast_frame *tmp;
+
+				framein(step, current);
+				tmp = step->t->frameout(step);
+
+				if (!tmp) {
+					continue;
+				} else if (inner_last) {
+					struct ast_frame *t;
+
+					/* Determine the last frame of the list before appending to it */
+					while ((t = AST_LIST_NEXT(inner_last, frame_list))) {
+						inner_last = t;
+					}
+					AST_LIST_NEXT(inner_last, frame_list) = tmp;
+				} else {
+					inner_prev = inner_head;
+					inner_head = tmp;
+					inner_last = tmp;
+				}
+			}
+
+			/* The current step did not create any frames = no frames for the next step */
+			/* The steps are not lost because framein buffered those for the next input frame */
+			if (!inner_last) {
+				inner_prev = inner_head;
+				inner_head = NULL;
+			}
+			if (inner_prev != frame_to_translate) {
+				ast_frfree(inner_prev); /* Frees just the intermediate lists */
+			}
+		}
+
+		/* This frame created no frames after translation = continue with next frame */
+		/* The frame is not lost because framein buffered it to be combined with the next frame */
+		if (!inner_head) {
+			continue;
+		} else if (out_last) {
+			struct ast_frame *t;
+
+			/* Determine the last frame of the list before appending to it */
+			while ((t = AST_LIST_NEXT(out_last, frame_list))) {
+				out_last = t;
+			}
+			AST_LIST_NEXT(out_last, frame_list) = inner_head;
+		} else {
+			out = inner_head;
+			out_last = inner_head;
 		}
-		out = p->t->frameout(p);
 	}
+
 	if (out) {
 		/* we have a frame, play with times */
 		if (!ast_tvzero(delivery)) {
